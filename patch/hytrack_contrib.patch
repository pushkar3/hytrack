Index: samples/cpp/hybridtrackingsample.cpp
===================================================================
--- samples/cpp/hybridtrackingsample.cpp	(revision 0)
+++ samples/cpp/hybridtrackingsample.cpp	(revision 0)
@@ -0,0 +1,121 @@
+#include <cv.h>
+#include <ml.h>
+#include <cvaux.h>
+#include <highgui.h>
+#include <stdio.h>
+#include <time.h>
+#include <iostream>
+
+#include "opencv2/tracker/hybridtracker.hpp"
+
+using namespace cv;
+using namespace std;
+
+Mat image;
+Rect selection;
+Point origin;
+bool selectObject = false;
+int trackObject = 0;
+
+void drawRectangle(Mat* image, Rect win)
+{
+	rectangle(*image, Point(win.x, win.y), Point(win.x + win.width, win.y
+			+ win.height), Scalar(0, 255, 0), 2, CV_AA);
+}
+
+void onMouse(int event, int x, int y, int, void*)
+{
+	if (selectObject)
+	{
+		selection.x = MIN(x, origin.x);
+		selection.y = MIN(y, origin.y);
+		selection.width = std::abs(x - origin.x);
+		selection.height = std::abs(y - origin.y);
+		selection &= Rect(0, 0, image.cols, image.rows);
+	}
+
+	switch (event)
+	{
+	case CV_EVENT_LBUTTONDOWN:
+		origin = Point(x, y);
+		selection = Rect(x, y, 0, 0);
+		selectObject = true;
+		break;
+	case CV_EVENT_LBUTTONUP:
+		selectObject = false;
+		trackObject = -1;
+		cout << "Init done" << endl;
+		break;
+	}
+}
+
+int main(int argc, char** argv)
+{
+
+	VideoCapture cap;
+
+	cap.open(1);
+	if (!cap.isOpened())
+	{
+		cout << "Failed to open camera" << endl;
+		return 0;
+	}
+	cout << "Opened camera" << endl;
+	cap >> image;
+
+	HybridTrackerParams params;
+	// motion model params
+	params.motion_model = CvMotionModel::LOW_PASS_FILTER;
+	params.low_pass_gain = 0.1;
+	// mean shift params
+	params.ms_tracker_weight = 0.8;
+	params.ms_params.tracking_type = CvMeanShiftTrackerParams::HS;
+	// feature tracking params
+	params.ft_tracker_weight = 0.2;
+	params.ft_params.feature_type = CvFeatureTrackerParams::SIFT;
+	params.ft_params.window_size = 30;
+
+	HybridTracker tracker(params);
+	namedWindow("Win", 1);
+	setMouseCallback("Win", onMouse, 0);
+
+	for (int i = 0; i < 1000; i++)
+	{
+
+		cap >> image;
+		if (image.data == NULL)
+			continue;
+
+		if (!image.empty())
+		{
+
+			if (trackObject < 0)
+			{
+				tracker.newTracker(image, selection);
+				trackObject = 1;
+			}
+
+			if (trackObject)
+			{
+				tracker.updateTracker(image);
+				drawRectangle(&image, tracker.getTrackingWindow());
+			}
+
+			if (selectObject && selection.width > 0 && selection.height > 0)
+			{
+				Mat roi(image, selection);
+				bitwise_not(roi, roi);
+			}
+
+			imshow("Win", image);
+
+			waitKey(30);
+		}
+		else
+			i = 0;
+	}
+
+	return 0;
+
+}
+
Index: modules/contrib/include/opencv2/tracker/hybridtracker.hpp
===================================================================
--- modules/contrib/include/opencv2/tracker/hybridtracker.hpp	(revision 0)
+++ modules/contrib/include/opencv2/tracker/hybridtracker.hpp	(revision 0)
@@ -0,0 +1,224 @@
+//*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                                License Agreement
+//                       For Open Source Computer Vision Library
+//
+// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
+// Copyright (C) 2008-2011, Willow Garage Inc., all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+// (including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort (including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+
+#ifndef __OPENCV_HYBRIDTRACKER_H_
+#define __OPENCV_HYBRIDTRACKER_H_
+
+#include "opencv2/core/core.hpp"
+#include "opencv2/core/operations.hpp"
+#include "opencv2/imgproc/imgproc.hpp"
+#include "opencv2/features2d/features2d.hpp"
+#include "opencv2/video/tracking.hpp"
+#include "opencv2/ml/ml.hpp"
+
+#ifdef __cplusplus
+
+namespace cv
+{
+
+// Motion model for tracking algorithm. Currently supports objects that do not move much.
+// To add Kalman filter
+struct CvMotionModel
+{
+	enum {LOW_PASS_FILTER = 0, KALMAN_FILTER = 1, EM = 2};
+	CvMotionModel(int model = LOW_PASS_FILTER, float low_pass_gain = 0.1)
+	{
+	}
+
+	CvMotionModel(int model = EM, CvEMParams em_params = CvEMParams())
+	{
+	}
+
+	float low_pass_gain; 	// low pass gain
+	CvEMParams em_params;	// EM parameters
+};
+
+// Mean Shift Tracker parameters for specifying use of HSV channel and CamShift parameters.
+struct CvMeanShiftTrackerParams
+{
+	enum {	H = 0, HS = 1, HSV = 2	};
+	CvMeanShiftTrackerParams(int tracking_type = CvMeanShiftTrackerParams::HS,
+			CvTermCriteria term_crit = CvTermCriteria())
+	{
+	}
+
+	int tracking_type;
+	float h_range[];
+	float s_range[];
+	float v_range[];
+	CvTermCriteria term_crit;
+};
+
+// Feature tracking parameters
+struct CvFeatureTrackerParams
+{
+	enum {	SIFT = 0, SURF = 1	};
+	CvFeatureTrackerParams(int feature_type = 0, int window_size = 0)
+	{
+		feature_type = 0;
+		window_size = 0;
+	}
+
+	int feature_type; // Feature type to use
+	int window_size; // Window size in pixels around which to search for new window
+};
+
+// Hybrid Tracking parameters for specifying weights of individual trackers and motion model.
+struct CvHybridTrackerParams
+{
+	CvHybridTrackerParams(float ft_tracker_weight = 0.5, float ms_tracker_weight = 0.5,
+			CvFeatureTrackerParams ft_params = CvFeatureTrackerParams(),
+			CvMeanShiftTrackerParams ms_params = CvMeanShiftTrackerParams(),
+			CvMotionModel model = CvMotionModel(CvMotionModel::LOW_PASS_FILTER, 0.1))
+	{
+	}
+
+	float ft_tracker_weight;
+	float ms_tracker_weight;
+	CvFeatureTrackerParams ft_params;
+	CvMeanShiftTrackerParams ms_params;
+	CvEMParams em_params;
+	int motion_model;
+	float low_pass_gain;
+};
+
+// Performs Camshift using parameters from MeanShiftTrackerParams
+class CvMeanShiftTracker
+{
+private:
+	Mat hsv, hue;
+	Mat backproj;
+	Mat mask, maskroi;
+	MatND hist;
+	Rect prev_trackwindow;
+	RotatedRect prev_trackbox;
+	Point2d prev_center;
+
+public:
+	CvMeanShiftTrackerParams params;
+
+	CvMeanShiftTracker();
+	CvMeanShiftTracker(CvMeanShiftTrackerParams _params = CvMeanShiftTrackerParams());
+	~CvMeanShiftTracker();
+	void newTrackingWindow(Mat image, Rect selection);
+	RotatedRect updateTrackingWindow(Mat image);
+	Mat getHistogramProjection(int type);
+	void setTrackingWindow(Rect _window);
+	Rect getTrackingWindow();
+	RotatedRect getTrackingEllipse();
+	Point2f getTrackingCenter();
+};
+
+// Performs SIFT/SURF feature tracking using parameters from FeatureTrackerParams
+class CvFeatureTracker
+{
+private:
+	FeatureDetector* detector;
+	DescriptorExtractor* descriptor;
+	DescriptorMatcher* matcher;
+	vector<DMatch> matches;
+
+	Mat prev_image;
+	vector<Mat> prev_desc_vector;
+	vector<KeyPoint> prev_keypoints;
+	Mat prev_desc;
+	Rect prev_trackwindow;
+	Point2d prev_center;
+
+public:
+	CvFeatureTrackerParams params;
+
+	CvFeatureTracker();
+	CvFeatureTracker(CvFeatureTrackerParams params = CvFeatureTrackerParams(0,0));
+	~CvFeatureTracker();
+	void newTrackingWindow(Mat image, Rect selection);
+	Rect updateTrackingWindow(Mat image);
+	void setTrackingWindow(Rect _window);
+	Rect getTrackingWindow();
+	Point2f getTrackingCenter();
+};
+
+// Performs Hybrid Tracking and combines individual trackers using EM or filters
+class CvHybridTracker
+{
+private:
+	CvMeanShiftTracker* mstracker;
+	CvFeatureTracker* fttracker;
+
+	CvMat* samples;
+	CvMat* labels;
+	CvEM em_model;
+
+	Rect prev_window;
+	Point2d prev_center;
+	Mat prev_proj;
+	RotatedRect trackbox;
+
+	inline float getL2Norm(Point2d p1, Point2d p2);
+	Mat getDistanceProjection(Mat image, Point2d center);
+	Mat getGaussianProjection(Mat image, int ksize, double sigma, Point2d center);
+	void updateTrackerWithEM(Mat image);
+	void updateTrackerWithLowPassFilter(Mat image);
+
+public:
+	CvHybridTrackerParams params;
+	CvHybridTracker();
+	CvHybridTracker(CvHybridTrackerParams params = CvHybridTrackerParams());
+	~CvHybridTracker();
+
+	void newTracker(Mat image, Rect selection);
+	void updateTracker(Mat image);
+	Rect getTrackingWindow();
+};
+
+typedef CvMotionModel MotionModel;
+typedef CvMeanShiftTrackerParams MeanShiftTrackerParams;
+typedef CvFeatureTrackerParams FeatureTrackerParams;
+typedef CvHybridTrackerParams HybridTrackerParams;
+typedef CvMeanShiftTracker MeanShiftTracker;
+typedef CvFeatureTracker FeatureTracker;
+typedef CvHybridTracker HybridTracker;
+}
+
+#endif
+
+#endif
Index: modules/contrib/doc/tracker.rst
===================================================================
--- modules/contrib/doc/tracker.rst	(revision 0)
+++ modules/contrib/doc/tracker.rst	(revision 0)
@@ -0,0 +1,172 @@
+Hybrid Tracking
+===============
+
+.. highlight:: cpp
+
+A hybrid tracker combines estimates from two tracking algorithms for robust tracking.
+
+The hybrid tracker uses MeanShift at its base. The MeanShift is a gradient descent technique that tries to find the best back projection. Like other optimization techniques, MeanShift can get stuck in local minimas or might require a lot of iterations to end up in the global minimum. To overcome this, hybrid trackers use various techniques. [Zhou09]_ use SIFT correspondence with MeanShift for tracking. [Avidan05]_ call this method ensemble tracking, where weak classifiers, which are trained online, are used alongwith MeanShift.
+
+MotionModel
+------------
+Defines the motion model for tracking. Defines parameters for that model.
+
+.. ocv:function:: MotionModel::MotionModel(int model = LOW_PASS_FILTER, float low_pass_gain = 0.1)
+Defines the motion model as a simple Low Pass Filter. 
+
+.. ocv:function:: MotionModel::MotionModel(int model = EM, CvEMParams em_params = CvEMParams())
+Defines the motion model with EM. Works well with occlusions.
+
+
+MeanShiftTrackerParams
+---------------------
+Defines parameters for the Mean Shift Tracker
+
+.. ocv:function:: MeanShiftTrackerParams::MeanShiftTrackerParams(int tracking_type = CvMeanShiftTrackerParams::HS, CvTermCriteria term_crit = CvTermCriteria()
+	:param tracking_type: Color channels to be used for tracking. Possible values are:
+		* **CvMeanShiftTrackerParams::H** Only use the H channel.
+		* **CvMeanShiftTrackerParams::HS** Only use the HS channels.
+		* **CvMeanShiftTrackerParams::HSV** Only use the HSV channels, rarely used.	
+    
+    :param term_crit: Termination criteria for the Cam shift algorithm.
+    
+    :param h_range[]: An array specifying what range of H will be used.
+    :param s_range[]: An array specifying what range of S will be used.
+    :param v_range[]: An array specifying what range of V will be used.
+
+FeatureTrackerParams
+---------------------
+Defines parameters for the Feature Tracker
+
+.. ocv:function:: FeatureTrackerParams::FeatureTrackerParams(int feature_type = 0, int window_size = 0)
+
+	:param feature_type: Features to be used for tracking. Possible values are:
+		* **CvFeatureTrackerParams::SIFT** Use SIFT with default parameters.
+		* **CvFeatureTrackerParams::SURF** Use SURF with default parameters.	
+    
+    :param window_size: Window size in pixels to be considered for searching.
+    
+HybridTrackerParams
+---------------------
+Defines parameters for the Hybrid Tracker
+
+.. ocv:function:: HybridTrackerParams::HybridTrackerParams(float ft_tracker_weight = 0.5, float ms_tracker_weight = 0.5,
+			CvFeatureTrackerParams ft_params = CvFeatureTrackerParams(),
+			CvMeanShiftTrackerParams ms_params = CvMeanShiftTrackerParams(),
+			CvMotionModel model = CvMotionModel(CvMotionModel::LOW_PASS_FILTER, 0.1)))
+
+	:param ft_tracker_weight: Initial importance of the feature tracker (< 1)
+	:param ms_tracker_weight: Initial importance of the mean shift tracker (< 1)
+	:param ft_params: FeatureTrackerParams for the feature tracking algorithm
+	:param ms_params: MeanShiftTrackerParams for the meanshift tracking algorithm
+	:param model: MotionModel for the tracking algorithm
+	
+MeanShiftTracker
+-----------------
+.. ocv:class:: MeanShiftTracker
+
+Tracking using CamShift
+
+.. ocv:function:: MeanShiftTracker::MeanShiftTracker(CvMeanShiftTrackerParams _params = CvMeanShiftTrackerParams())
+
+MeanShiftTracker::newTrackingWindow
+------------------------------------
+Defines a new tracking window
+
+.. ocv:function:: MeanShiftTracker::newTrackingWindow(Mat image, Rect selection)
+
+MeanShiftTracker::updateTrackingWindow
+--------------------------------------
+Updates the tracker
+
+.. ocv:function:: RotatedRect MeanShiftTracker::updateTrackingWindow(Mat image)
+
+MeanShiftTracker::getHistogramProjection
+---------------------------------------
+Gives a probability distribution graph of where it thinks the object is
+
+.. ocv:function:: Mat MeanShiftTracker::getHistogramProjection(int type)
+
+MeanShiftTracker::setTrackingWindow
+------------------------------------
+Sets the tracking window
+
+.. ocv:function:: void MeanShiftTracker::setTrackingWindow(Rect _window)
+
+MeanShiftTracker::getTrackingWindow
+------------------------------------
+Gets the tracking window
+
+.. ocv:function:: Rect MeanShiftTracker::getTrackingWindow()
+
+MeanShiftTracker::getTrackingCenter
+------------------------------------
+Gets the tracking center
+
+.. ocv:function:: Point2f MeanShiftTracker::getTrackingCenter()
+
+FeatureTracker
+-----------------
+.. ocv:class:: FeatureTracker
+
+Tracking using SIFT/SURF features
+
+.. ocv:function:: FeatureTracker::FeatureTracker(CvFeatureTrackerParams _params = CvFeatureTrackerParams())
+
+FeatureTracker::newTrackingWindow
+------------------------------------
+Defines a new tracking window
+
+.. ocv:function:: FeatureTracker::newTrackingWindow(Mat image, Rect selection)
+
+FeatureTracker::updateTrackingWindow
+--------------------------------------
+Updates the tracker
+
+.. ocv:function:: Rect FeatureTracker::updateTrackingWindow(Mat image)
+
+FeatureTracker::setTrackingWindow
+------------------------------------
+Sets the tracking window
+
+.. ocv:function:: void FeatureTracker::setTrackingWindow(Rect _window)
+
+FeatureTracker::getTrackingWindow
+------------------------------------
+Gets the tracking window
+
+.. ocv:function:: Rect FeatureTracker::getTrackingWindow()
+
+FeatureTracker::getTrackingCenter
+------------------------------------
+Gets the tracking center
+
+.. ocv:function:: Point2f FeatureTracker::getTrackingCenter()
+
+	
+HybridTracker
+--------------
+.. ocv:class:: HybridTracker
+Computes a probability density function from the region of interest selected and tracks it. The tracker consists of two or more trackers whose results are used in an EM framework.
+
+.. ocv:function:: HybridTracker::HybridTracker(CvHybridTrackerParams _params = CvHybridTrackerParams())
+
+MeanShiftTracker::newTracker
+------------------------------------
+Defines a new tracking window
+
+.. ocv:function:: HybridTracker::newTrackingWindow(Mat image, Rect selection)
+
+HybridTracker::updateTracker
+--------------------------------------
+Updates the tracker using the parameters from the motion model. It can either use a low pass filter or EM.
+
+.. ocv:function:: void HybridTracker::updateTrackingWindow(Mat image)
+
+The function implements a hybrid tracker as given in [Zhou09]_.
+
+
+
+.. [Zhou09] Zhou, H. and Yuan, Y. and Shi, C.. Object tracking using SIFT features and mean shift.
+
+... [Avidan05] Avidan, S.. Ensemble tracking.
Index: modules/contrib/src/featuretracker.cpp
===================================================================
--- modules/contrib/src/featuretracker.cpp	(revision 0)
+++ modules/contrib/src/featuretracker.cpp	(revision 0)
@@ -0,0 +1,147 @@
+//*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                                License Agreement
+//                       For Open Source Computer Vision Library
+//
+// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
+// Copyright (C) 2008-2011, Willow Garage Inc., all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+// (including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort (including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+#include "precomp.hpp"
+#include "opencv2/tracker/hybridtracker.hpp"
+
+using namespace cv;
+
+CvFeatureTracker::CvFeatureTracker(CvFeatureTrackerParams _params) : params(_params)
+{
+	switch (params.feature_type)
+	{
+	case CvFeatureTrackerParams::SIFT:
+		detector = new SiftFeatureDetector(
+				SIFT::DetectorParams::GET_DEFAULT_THRESHOLD(),
+				SIFT::DetectorParams::GET_DEFAULT_EDGE_THRESHOLD(),
+				SIFT::CommonParams::AVERAGE_ANGLE);
+	case CvFeatureTrackerParams::SURF:
+		detector = new SurfFeatureDetector(400, 3, 4);
+	}
+
+	descriptor = new SurfDescriptorExtractor(3, 4, false);
+
+	matcher = new BruteForceMatcher<L2<float> > ();
+}
+
+
+CvFeatureTracker::~CvFeatureTracker()
+{
+}
+
+void CvFeatureTracker::newTrackingWindow(Mat image, Rect selection)
+{
+	prev_trackwindow = selection;
+	prev_image = image;
+
+	Mat mask = Mat::zeros(image.size(), CV_8UC1);
+	rectangle(mask, Point(prev_trackwindow.x, prev_trackwindow.y), Point(prev_trackwindow.x
+			+ prev_trackwindow.width, prev_trackwindow.y + prev_trackwindow.height), Scalar(
+			255), CV_FILLED);
+
+	prev_desc_vector.clear();
+	detector->detect(prev_image, prev_keypoints, mask);
+
+	if (prev_keypoints.size() > 0)
+		descriptor->compute(prev_image, prev_keypoints, prev_desc);
+}
+
+Rect CvFeatureTracker::updateTrackingWindow(Mat image)
+{
+	newTrackingWindow(prev_image, prev_trackwindow);
+
+	vector<KeyPoint> current_keypoints;
+	Mat current_desc;
+
+	int windowSize = params.window_size;
+	Rect window(prev_trackwindow.x - windowSize, prev_trackwindow.y - windowSize,
+			prev_trackwindow.width + windowSize, prev_trackwindow.height + windowSize);
+
+	Mat mask = Mat::zeros(image.size(), CV_8UC1);
+	rectangle(mask, Point(window.x, window.y), Point(window.x + window.width,
+			window.y + window.height), Scalar(255), CV_FILLED);
+
+	detector->detect(image, current_keypoints, mask);
+
+	if (current_keypoints.size() > 4)
+	{
+		descriptor->compute(image, current_keypoints, current_desc);
+		matcher->match(prev_desc, current_desc, matches);
+
+		Point p0 = prev_keypoints[matches[0].trainIdx].pt;
+		Point n0 = current_keypoints[matches[0].queryIdx].pt;
+
+#if 0
+		Point p1 = prev_keypoints[matches[1].trainIdx].pt;
+		Point n1 = current_keypoints[matches[1].queryIdx].pt;
+
+		double dp = sqrt((p0.x - p1.x)*(p0.x - p1.x) + (p0.y - p1.y)*(p0.y - p1.y));
+		double dn = sqrt((n0.x - n1.x)*(n0.x - n1.x) + (n0.y - n1.y)*(n0.y - n1.y));
+
+		double scale = dn/dp;
+		prev_trackwindow.width *= scale;
+		prev_trackwindow.height *= scale;
+#endif
+
+		prev_trackwindow.x += (p0.x - n0.x);
+		prev_trackwindow.y += (p0.y - n0.y);
+	}
+
+	prev_center.x = prev_trackwindow.x;
+	prev_center.y = prev_trackwindow.y;
+	return prev_trackwindow;
+}
+
+void CvFeatureTracker::setTrackingWindow(Rect _window)
+{
+	prev_trackwindow = _window;
+}
+
+Rect CvFeatureTracker::getTrackingWindow()
+{
+	return prev_trackwindow;
+}
+
+
+Point2f CvFeatureTracker::getTrackingCenter()
+{
+	return prev_center;
+}
Index: modules/contrib/src/colortracker.cpp
===================================================================
--- modules/contrib/src/colortracker.cpp	(revision 0)
+++ modules/contrib/src/colortracker.cpp	(revision 0)
@@ -0,0 +1,132 @@
+//*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                                License Agreement
+//                       For Open Source Computer Vision Library
+//
+// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
+// Copyright (C) 2008-2011, Willow Garage Inc., all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+// (including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort (including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+#include "precomp.hpp"
+#include "opencv2/tracker/hybridtracker.hpp"
+
+using namespace cv;
+using namespace std;
+
+CvMeanShiftTracker::CvMeanShiftTracker(CvMeanShiftTrackerParams _params) : params(_params)
+{
+}
+
+CvMeanShiftTracker::~CvMeanShiftTracker()
+{
+}
+
+void CvMeanShiftTracker::newTrackingWindow(Mat image, Rect selection)
+{
+	hist.release();
+	int channels[] = { 0, 0 , 1, 1};
+	float hrange[] = { 0, 180 };
+	float srange[] = { 0, 1 };
+ 	const float* ranges[] = {hrange, srange};
+
+	cvtColor(image, hsv, CV_BGR2HSV);
+	inRange(hsv, Scalar(0, 30, MIN(10, 256)), Scalar(180, 256, MAX(10, 256)), mask);
+
+	hue.create(hsv.size(), CV_8UC2);
+	mixChannels(&hsv, 1, &hue, 1, channels, 2);
+
+	Mat roi(hue, selection);
+	Mat maskroi(mask, selection);
+	int ch[] = {0, 1};
+	int chsize[] = {32, 32};
+	calcHist(&roi, 1, ch, maskroi, hist, 1, chsize, ranges);
+	normalize(hist, hist, 0, 255, CV_MINMAX);
+
+	prev_trackwindow = selection;
+}
+
+RotatedRect CvMeanShiftTracker::updateTrackingWindow(Mat image)
+{
+	int channels[] = { 0, 0 , 1, 1};
+	float hrange[] = { 0, 180 };
+	float srange[] = { 0, 1 };
+	const float* ranges[] = {hrange, srange};
+
+	cvtColor(image, hsv, CV_BGR2HSV);
+	inRange(hsv, Scalar(0, 30, MIN(10, 256)), Scalar(180, 256, MAX(10, 256)), mask);
+	hue.create(hsv.size(), CV_8UC2);
+	mixChannels(&hsv, 1, &hue, 1, channels, 2);
+	int ch[] = {0, 1};
+	calcBackProject(&hue, 1, ch, hist, backproj, ranges);
+	backproj &= mask;
+	prev_trackbox = CamShift(backproj, prev_trackwindow, TermCriteria(CV_TERMCRIT_EPS | CV_TERMCRIT_ITER, 10, 1));
+	int cols = backproj.cols, rows = backproj.rows, r = (MIN(cols, rows) + 5) / 6;
+	prev_trackwindow = Rect(prev_trackwindow.x - r, prev_trackwindow.y - r, prev_trackwindow.x + r,
+			prev_trackwindow.y + r) & Rect(0, 0, cols, rows);
+
+	prev_center.x = prev_trackwindow.x + prev_trackwindow.width / 2;
+	prev_center.y = prev_trackwindow.y + prev_trackwindow.height / 2;
+
+	return prev_trackbox;
+}
+
+Mat CvMeanShiftTracker::getHistogramProjection(int type)
+{
+	Mat ms_backproj_f(backproj.size(), type);
+	backproj.convertTo(ms_backproj_f, type);
+	return ms_backproj_f;
+}
+
+void CvMeanShiftTracker::setTrackingWindow(Rect window)
+{
+	prev_trackwindow = window;
+}
+
+Rect CvMeanShiftTracker::getTrackingWindow()
+{
+	return prev_trackwindow;
+}
+
+RotatedRect CvMeanShiftTracker::getTrackingEllipse()
+{
+	return prev_trackbox;
+}
+
+Point2f CvMeanShiftTracker::getTrackingCenter()
+{
+	return prev_center;
+}
+
+
Index: modules/contrib/src/hybridtracker.cpp
===================================================================
--- modules/contrib/src/hybridtracker.cpp	(revision 0)
+++ modules/contrib/src/hybridtracker.cpp	(revision 0)
@@ -0,0 +1,208 @@
+//*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                                License Agreement
+//                       For Open Source Computer Vision Library
+//
+// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
+// Copyright (C) 2008-2011, Willow Garage Inc., all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+// (including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort (including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+#include "precomp.hpp"
+#include "opencv2/tracker/hybridtracker.hpp"
+
+using namespace cv;
+using namespace std;
+
+CvHybridTracker::CvHybridTracker()
+{
+
+}
+
+
+CvHybridTracker::CvHybridTracker(HybridTrackerParams _params) : params(_params)
+{
+	params.ft_params.feature_type = CvFeatureTrackerParams::SIFT;
+	mstracker = new CvMeanShiftTracker(params.ms_params);
+	fttracker = new CvFeatureTracker(params.ft_params);
+}
+
+CvHybridTracker::~CvHybridTracker()
+{
+	if(mstracker != NULL) delete mstracker;
+	if(fttracker != NULL) delete fttracker;
+}
+
+inline float CvHybridTracker::getL2Norm(Point2d p1, Point2d p2)
+{
+	float distance = (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);
+	return sqrt(distance);
+}
+
+Mat CvHybridTracker::getDistanceProjection(Mat image, Point2d center)
+{
+	Mat hist(image.size(), CV_64F);
+
+	double lu = getL2Norm(Point(0, 0), center);
+	double ru = getL2Norm(Point(0, image.size().width), center);
+	double rd = getL2Norm(Point(image.size().height, image.size().width), center);
+	double ld = getL2Norm(Point(image.size().height, 0), center);
+
+	double max = (lu < ru) ? lu : ru;
+	max = (max < rd) ? max : rd;
+	max = (max < ld) ? max : ld;
+
+	for (int i = 0; i < hist.rows; i++)
+		for (int j = 0; j < hist.cols; j++)
+			hist.at<double> (i, j) = 1.0 - (getL2Norm(Point(i, j), center)/max);
+
+	return hist;
+}
+
+Mat CvHybridTracker::getGaussianProjection(Mat image, int ksize, double sigma,	Point2d center)
+{
+	Mat kernel = getGaussianKernel(ksize, sigma, CV_64F);
+	double max = kernel.at<double> (ksize/2);
+
+	Mat hist(image.size(), CV_64F);
+	for (int i = 0; i < hist.rows; i++)
+		for (int j = 0; j < hist.cols; j++)
+		{
+			int pos = getL2Norm(Point(i, j), center);
+			if (pos < ksize / 2.0)
+				hist.at<double> (i, j) = 1.0 - (kernel.at<double> (pos)/max);
+		}
+
+	return hist;
+}
+
+
+void CvHybridTracker::newTracker(Mat image, Rect selection)
+{
+	prev_proj = Mat::zeros(image.size(), CV_64FC1);
+	prev_center = Point2f(selection.x+selection.width/2.0, selection.y+selection.height/2.0);
+	prev_window = selection;
+
+	mstracker->newTrackingWindow(image, selection);
+	fttracker->newTrackingWindow(image, selection);
+
+	params.em_params.covs = NULL;
+	params.em_params.means = NULL;
+	params.em_params.probs = NULL;
+	params.em_params.nclusters = 1;
+	params.em_params.weights = NULL;
+	params.em_params.cov_mat_type = CvEM::COV_MAT_DIAGONAL;
+	params.em_params.start_step = CvEM::START_AUTO_STEP;
+	params.em_params.term_crit.max_iter = 10;
+	params.em_params.term_crit.epsilon = 0.1;
+	params.em_params.term_crit.type = CV_TERMCRIT_ITER | CV_TERMCRIT_EPS;
+
+	samples = cvCreateMat(2, 10, CV_32FC1);
+	labels = cvCreateMat(2, 1, CV_32SC1);
+}
+
+void CvHybridTracker::updateTracker(Mat image)
+{
+	mstracker->updateTrackingWindow(image);
+	fttracker->updateTrackingWindow(image);
+
+//	if (params.motion_model = CvMotionModel::EM)
+//		updateTrackerWithEM(image);
+//	else
+	updateTrackerWithLowPassFilter(image);
+
+	mstracker->setTrackingWindow(prev_window);
+	fttracker->setTrackingWindow(prev_window);
+}
+
+void CvHybridTracker::updateTrackerWithEM(Mat image)
+{
+	Mat ms_backproj = mstracker->getHistogramProjection(CV_64F);
+	Mat ms_distproj = getDistanceProjection(image, mstracker->getTrackingCenter());
+	Mat ms_proj = ms_backproj.mul(ms_distproj);
+
+	float dist_err = getL2Norm(mstracker->getTrackingCenter(), fttracker->getTrackingCenter());
+	Mat ft_gaussproj = getGaussianProjection(image, dist_err, -1, fttracker->getTrackingCenter());
+	Mat ft_distproj = getDistanceProjection(image, fttracker->getTrackingCenter());
+	Mat ft_proj = ft_gaussproj.mul(ft_distproj);
+
+	Mat proj = params.ms_tracker_weight * ms_proj + params.ft_tracker_weight * ft_proj + prev_proj;
+	int sample_count = countNonZero(proj);
+	if(samples != NULL) cvReleaseMat(&samples);
+	samples = cvCreateMat(2, sample_count, CV_32FC1);
+
+	int count = 0;
+	for (int i = 0; i < proj.rows; i++)
+		for (int j = 0; j < proj.cols; j++)
+			if (proj.at<double> (i, j) > 0)
+			{
+				samples->data.fl[count * 2] = i;
+				samples->data.fl[count * 2 + 1] = j;
+				count++;
+			}
+
+	params.em_params.means = em_model.get_means();
+	params.em_params.covs = (const CvMat**) em_model.get_covs();
+	params.em_params.weights = em_model.get_weights();
+
+	em_model.train(samples, 0, params.em_params, labels);
+	Point2f center = em_model.getMeans().at<Point2d> (0);
+	prev_proj = proj;
+	prev_center = center;
+	prev_window.x = center.x;
+	prev_window.y = center.y;
+}
+
+void CvHybridTracker::updateTrackerWithLowPassFilter(Mat image)
+{
+	RotatedRect ms_track = mstracker->getTrackingEllipse();
+	Point2f ft_center = fttracker->getTrackingCenter();
+
+	trackbox = ms_track;
+	trackbox.center.x *= params.ms_tracker_weight*trackbox.center.x + params.ft_tracker_weight*ft_center.x;
+	trackbox.center.y *= params.ms_tracker_weight*trackbox.center.y + params.ft_tracker_weight*ft_center.y;
+
+	float a = params.low_pass_gain;
+	trackbox.center.x *= a*trackbox.center.x + (1.0-a)*prev_center.x;
+	trackbox.center.y *= a*trackbox.center.y + (1.0-a)*prev_center.y;
+
+	prev_window.x = trackbox.center.x - prev_window.width/2.0;
+	prev_window.y = trackbox.center.y - prev_window.height/2.0;
+}
+
+Rect CvHybridTracker::getTrackingWindow()
+{
+	return prev_window;
+}
+
Index: modules/contrib/precomp.hpp
===================================================================
--- modules/contrib/precomp.hpp	(revision 0)
+++ modules/contrib/precomp.hpp	(revision 0)
@@ -0,0 +1,60 @@
+/*M///////////////////////////////////////////////////////////////////////////////////////
+//
+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
+//
+//  By downloading, copying, installing or using the software you agree to this license.
+//  If you do not agree to this license, do not download, install,
+//  copy or use the software.
+//
+//
+//                        Intel License Agreement
+//                For Open Source Computer Vision Library
+//
+// Copyright (C) 2000, Intel Corporation, all rights reserved.
+// Third party copyrights are property of their respective owners.
+//
+// Redistribution and use in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+//   * Redistribution's of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//
+//   * Redistribution's in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//
+//   * The name of Intel Corporation may not be used to endorse or promote products
+//     derived from this software without specific prior written permission.
+//
+// This software is provided by the copyright holders and contributors "as is" and
+// any express or implied warranties, including, but not limited to, the implied
+// warranties of merchantability and fitness for a particular purpose are disclaimed.
+// In no event shall the Intel Corporation or contributors be liable for any direct,
+// indirect, incidental, special, exemplary, or consequential damages
+// (including, but not limited to, procurement of substitute goods or services;
+// loss of use, data, or profits; or business interruption) however caused
+// and on any theory of liability, whether in contract, strict liability,
+// or tort (including negligence or otherwise) arising in any way out of
+// the use of this software, even if advised of the possibility of such damage.
+//
+//M*/
+
+#ifndef __TRACKER_H_
+#define __TRACKER_H_
+
+#if _MSC_VER >= 1200
+#pragma warning( disable: 4251 4710 4711 4514 4996 )
+#endif
+
+#ifdef HAVE_CVCONFIG_H
+#include "cvconfig.h"
+#endif
+
+#include "opencv2/core/core.hpp"
+#include "opencv2/imgproc/imgproc.hpp"
+#include "opencv2/features2d/features2d.hpp"
+#include "opencv2/video/tracking.hpp"
+#include "opencv2/ml/ml.hpp"
+
+#endif
+
